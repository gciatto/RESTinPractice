\frametitle{Uniform Interface}

\begin{itemize}
\item The uniform interface constraint defines the interface between clients and servers.
\item This is probably secret of \rest's simplicity and strength.
\item \restful\ systems expose a standard, unambiguous, clear and human-readable API because of this constraint.
\begin{itemize}
\item Such a principle allows for model-driven approaches.
\end{itemize}
\end{itemize}

\begin{block}{Uniform Interface Requirements}
\begin{itemize}
\item Resource-based
\item Manipulation of Resources Through Representations
\item Self-descriptive Messages
\item HATEOAS (dafuq ?!)

\end{itemize}
\end{block}

\framebreak


\begin{block}{Resource-Based}
\begin{itemize}
\item \restful\ systems handle \emph{resources}: servers host resources and clients want to CRUD them
\begin{itemize}
\item[$\Rightarrow$] \textbf{C}reate or \textbf{R}ead or \textbf{U}pdate or \textbf{D}elete
\end{itemize}
% \item Resources are not accessed (CRUDed) directly but through their representation(s)
\item Resources have a \emph{hierarchical} nature
\item Resources are identified and referenced by the mean of URIs
\begin{itemize}
\item[$\Rightarrow$] \textbf{U}niform \textbf{R}esource \textbf{I}dentifier
\end{itemize}

\end{itemize}
\end{block}

\begin{block}{HTTP Verbs}

\begin{itemize}
\item CRUD in Web-based systems means exploiting HTTP methods, which are often called ``verbs'' because of their usage within APIs:
\begin{itemize}
\item POST is used for resource Creation
\item GET mean is to Read resources
\item PUT aim is to Update resources
\item DELETE is used to Delete resources
\end{itemize}
\item HTTP Status codes and their general purpose semantics are part of the uniform interface too:
\begin{itemize}
\item e.g. any successful request will result in a \texttt{200:\,Ok} or \texttt{204:\,No\,Content} status code (depending on weather the response has body or not)
\item e.g. trying to GET or DELETE any non-existent resource will result in a \texttt{404:\,Not\,Found} status code
\item e.g. POSTing an already-existing user will result in a \texttt{409:\,Conflict} status code
\end{itemize}
\end{itemize}
\end{block}

\framebreak

\begin{itemize}
\item Example of resource creation:
\begin{itemize}
\item we want to edit some user's username from \texttt{gciatto92} to \texttt{gciatto}
\item suppose no authentication is needed
\end{itemize}
\end{itemize}

\begin{alertblock}{Example of non-\restful\ approach}
\begin{itemize}
\item \texttt{GET http://example.com/users?\-user=gciatto92\&\-operation=changeName\&\-newName=gciatto}
\item[]
\item[$\times$] RPC style: the request contains the to-be-called operation
\item[$\times$] No semantics for \texttt{GET} verb
\item[$\times$] Which resource am I editing?
\end{itemize}
\end{alertblock}

\begin{exampleblock}{Example of \restful\ approach}
\begin{itemize}
\item \texttt{PUT http://example.com/users/gciatto92?newName=gciatto}
\item[]
\item[$\checkmark$] I'm editing the resource \texttt{gciatto92}, which is a user, composing the \texttt{users} resource, which represents the collection of registered users
\item[$\checkmark$] \texttt{PUT} verb means Update and that's what I am doing
\item[$\checkmark$] URI queries are simply a mean for payload transport
\end{itemize}
\end{exampleblock}

\framebreak

\begin{block}{Manipulation of Resources Through Representations}

\begin{itemize}
\item Resources are not accessed (CRUDed) directly but through their representation(s)
\item Representations should expose resources traits to clients enabling them to do what they are allowed to, no more and no less
\item Clients cannot make assumptions upon resources implementations, they can only exploit representations
\end{itemize}
\end{block}

\begin{block}{Self-descriptive Messages}

\begin{itemize}
\item Each message must include enough information to describe how to process the message itself
\begin{itemize}
\item E.g. HTTP's \emph{Content Negotiation} is a powerfull feature: use it! \texttt{Accept} and \texttt{Content-Type} headers allow different representations for resources exposing some business logic
\item Prefer JSON but try to support XML
\end{itemize}

\end{itemize}
\end{block}

\framebreak

\begin{block}{HATEOAS - \textbf{H}ypermedia \textbf{A}s \textbf{T}he \textbf{E}ngine \textbf{O}f \textbf{A}pplication \textbf{S}tate}

\begin{itemize}
\item Difficult constraint to fully accomplish IMHO
\item Weak definition is enough for our concerns: \emph{``Services responses should contain \emph{`relational links'} when they may be useful''}
\item Relationships are standardized
\item In completely-RESTful HTTP-based systems, relational links are the only mean used by clients to interact with servers
\end{itemize}
\end{block}

\begin{example}
\texttt{GET http://example.com/users?limit=3} \\
supposing the first three users are \texttt{gciatto}, \texttt{mfrancia} and \texttt{mneri}, it should return something like:
\begin{lstlisting}[basicstyle=\scriptsize]
[
  {
    "username" = "gciatto",
    "links" = [
      { "rel" = "next", "href" = "/users/mfrancia" },
      { "rel" = "prev", "href" = "/users/mneri" },
      { "rel" = "first", "href" = "/users/gciatto" },
      { "rel" = "last", "href" = "/users/mneri" },
      { "rel" = "self", "href" = "/users/gciatto" }
    ]
  }
  ...
]
\end{lstlisting}
\end{example}

